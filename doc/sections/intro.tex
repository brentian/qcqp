\documentclass[../main]{subfiles}

\begin{document}
\section{Develop Plan}

The first part is devoted to SDP relaxations.

\begin{itemize}
      \tightlist
      \item We first test HQCQP for vectors, add support for SeDuMi, should be able to switch SDP solvers
      \item Extend to non-homogeneous QCQP.
      \item Develop and test both relaxations, see \ref{sdp-method-1}, \ref{sdp-method-2}
      \item We test on well-known problems (vectors), e.g., QKP (quadratic knapsack), Max-cut, ...
      \item Start to test matrix variable problems, see \ref{sdp-extending}, SNL, QAP,
            etc using vectorized method.
      \item Introduce matrix variables, ..., if needed.
\end{itemize}

Start with Pure Python or Julia interface as a fast prototype. Then migrate to C/C++ interface with Python and Matlab support.

The second part is devoted to ``Refinement''. to be discussed.

The third part is for Branch-and-cut method, using ideas from integer programming,
to create a global QCQP solver using SDP as lower bound in the branching process. to be discussed.

Last part is for modeling and AMLs support.

\begin{itemize}
      \tightlist
      \item in Python one can use cvxpy or other AMLs; in Julia one may extend JuMP.
      \item add support for COPT?
\end{itemize}

\section{Scope of Work}
Develop a QCQP solver that uses SDP-relaxation-and-refinement approach.
The QCQP solver should be problem-independent that works for any QCQP
instance.
\subsection{Modeling interface}\label{modeling-interface}

The modeling interface is domain specific language, a simple tool for
user to define a \textbf{QCQP} problem, then the solver translates into
canonical form of QCQP. For example, for a HQCQP, canonical form
includes parameters \(Q\), \(A_i, b_i, \forall i\)

To-dos:

\begin{itemize}
      \tightlist
      \item
            The modeling part does the canonicalization, works like cvxpy, yalmip,
            etc.
      \item
            Directly use COPT.
\end{itemize}

See \cite{agrawal_rewriting_2018}, \cite{diamond_cvxpy_2016},
\cite{dunning_jump_2017}, \cite{lofberg_yalmip_2004}

\subsection{SDP interface}\label{sdp-interface}

The SDP interface should be solver \textbf{independent}. SDP interface
starts with canonical form to create a SDP-relaxation. So the users do
not have to derive SDP by themselves. The interface should output a SDP
problem in a standard format, e.g., SDPA format, that can be accepted by
any SDP solver.

To-dos including:

\begin{itemize}
      \tightlist
      \item starts with canonical form.
      \item interface with solver: create problems, extract solutions, status,
            etc.
      \item consider two types of relaxation: method-I, method-II.
\end{itemize}


We consider two types of SDP relaxations:

\subsection{Local Refinement}\label{local-refinement}

Local Refinement from SDP solution to QP seems to be problem dependent,
whereas we can start with:

\begin{itemize}
      \tightlist
      \item
            Use Gurobi to do the refinement
      \item
            use existing methods, including residual minimization (SNL),
            randomization (for BQP), see \cite{luo_semidefinite_2010} and papers for
            SNL.
      \item
            add an \textbf{option} for user to choose a refinement method.
\end{itemize}


\subsection{Branch-and-Cut for Global Optimization}\label{branch-and-cut}


\end{document}